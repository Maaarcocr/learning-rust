#+Title: Timer Future
#+SETUPFILE: ../reveal.setup

* Timer

  + A future which waits a fixed amount of time
  + Constantly re-check how much time has elapsed
    + In reality you might want to use OS primitives here!
    + This is a bit in-efficient but will work for now

* Time handling in Rust

  + ~Instant~ refers to a specific point in time
  + ~Duration~ is the time between _two_ ~Instants~

  #+BEGIN_SRC rust
    let then = Instant::now();
    let dur = Duration::from_secs(3);
    loop {
        if instant.elapsed() >= then {
            println!("Time's up!");
            break;
        }
    }
  #+END_SRC

* 

  #+INCLUDE: "exercises/01-future-anatomy/src/bin/10_timer.rs" src rust


* 

  #+BEGIN_SRC rust
    use std::{future::Future,pin::Pin,task::{Context, Poll}};
    
    impl Timer {
        fn new(len: Duration) -> Self {
            Self {
                now: Instant::now(),
                len,
            }
        }
    }
    
    impl Future for Timer {
        type Output = ();
        
        fn poll(self: Pin<&mut Self>, ctx: &mut Context<'_>) -> Poll<()> {
            if self.now.elapsed() >= self.len {
                Poll::Ready(())
            } else {
                ctx.waker().wake_by_ref();
                Poll::Pending
            }
        }
    }
    
    #[async_std::main]
    async fn main() {
        println!("Hello world!");
        Timer::new(Duration::from_secs(1)).await;
        println!("This is one second later!");
    }
  #+END_SRC

* [[file:README.org][Back to index]]

