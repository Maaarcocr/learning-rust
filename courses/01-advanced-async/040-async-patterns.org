#+Title: Some common async patterns
#+SETUPFILE: ../../reveal.setup

* Async applications require concurrency-safe patterns

* Channels!

  + A great mechanism to avoid shared state between futures
  + Use an async channel implementation
    + ~async-channel~ crate (re-exported from ~async-std~)
    + ~flume~ crate provides both sync and async channel APIs

* 

  #+INCLUDE: "exercises/02-async-patterns/src/bin/01_channels.rs" src rust

* Bounded vs unbounded

  *+Not so+ controversial opinion time*: don't use unbounded channels!  Why?

  \\
  
  + Bounded channels :: Fixed size channels that are _predictable_ and
    provide _backpressure_
  + Unbounded channels :: Dynamically grow and shrink with demand.
    More _dynamic_ but can grow _infinitely_

* What is backpressure?

  + A mechanism to bind the production rate to the consumption rate of
    two components
  + Or: slow down producers for slow consumers
  + This can overall slow down a system but prevent it from crashing

* Backpressure example

  file:imgs/bp0.png

* Backpressure example

  file:imgs/bp1.png

* Backpressure example

  file:imgs/bp2.png

* Backpressure example

  file:imgs/bp3.png

* Backpressure example

  file:imgs/bp6.png

* Backpressure example

  file:imgs/bp8.png

* Backpressure example

  file:imgs/bp10.png

* Demo bounded

  #+INCLUDE: "exercises/02-async-patterns/src/bin/02_backpressure_bounded.rs" src rust

  #+BEGIN_SRC console
  $ time -v target/debug/02_backpressure_bounded
    	Command being timed: "target/debug/02_backpressure_bounded"
	Percent of CPU this job got: 5%
	Elapsed (wall clock) time (h:mm:ss or m:ss): 0:10.02
	Maximum resident set size (kbytes): 4136
	Major (requiring I/O) page faults: 291
	Minor (reclaiming a frame) page faults: 457
  #+END_SRC

* Demo unbounded


  #+INCLUDE: "exercises/02-async-patterns/src/bin/02_backpressure_unbounded.rs" src rust

  #+BEGIN_SRC console
  $ time -v target/debug/02_backpressure_unbounded
	Command being timed: "target/debug/02_backpressure_unbounded"
	Percent of CPU this job got: 3%
	Elapsed (wall clock) time (h:mm:ss or m:ss): 0:10.02
	Maximum resident set size (kbytes): 11984
	Major (requiring I/O) page faults: 378
	Minor (reclaiming a frame) page faults: 2775
  #+END_SRC
  

* Types of channels

  + Bounded
  + Unbounded
  + Single Producer, Single Consumer (SPSC)
  + Multi Producer, Single Consumer (MPSC)
  + Multi Producer, Multi Consumer (MPMC)
  + Oneshot

* Synchronisation and Locking

  + Avoid using certain ~std::sync~ types (Mutex, RwLock, ...)
  + ~async_std::sync~ or ~tokio::sync~ are better, async-safe
    alternatives

* How to stop futures?

  + ~JoinHandle<T>~ can be used to explicitly cancel future
  + Or cancel future implicitly
    + ...how?

* ~select!~

  + Execute a number of futures and pick the first one that resolves
  + Provided by ~futures::select!~ or ~tokio::select!~
  + Other running futures are cancelled!
    + Are your future's cancel resistant?

  #+INCLUDE: "exercises/02-async-patterns/src/bin/04_select_tokio.rs" src rust

* [[file:README.org][Back to index]]
